{"version":3,"sources":["config/index.ts","api/membership.ts","contracts/membership/index.ts","config/abi/erc20.ts","utils/getRpcUrl.ts","utils/providers.ts","utils/index.ts","contracts/usdc/index.ts","views/Membership.tsx"],"names":["ChainIdBsc","ChainIdPolygon","getNonceSignature","providerName","chosenProvider","getProvider","provider","ethers","providers","Web3Provider","getSigner","endpoint","process","REACT_APP_API_HOSTNAME","axios","get","res","data","MAINNET","polygonTestnetTokens","link","chainId","TESTNET","address","decimals","symbol","name","projectLink","membershipContract","feeAddress","allowance","abi","membershipAbi","ALCHEMY_API_KEY","REACT_APP_ALCHEMY_HOSTNAME","REACT_APP_ALCHEMY_API_KEY","web3","createAlchemyWeb3","mint","signature","message","MembershipContract","eth","Contract","console","log","signer","getAddress","walletAddress","transactionParameters","to","from","gas","utils","hexlify","methods","encodeABI","request","method","params","catch","error","warn","Interface","ERC20_ABI","ERC20_BYTES32_ABI","nodes","REACT_APP_PUBLIC_NODE_1","REACT_APP_PUBLIC_NODE_2","REACT_APP_PUBLIC_NODE_3","RPC_URL","REACT_APP_PUBLIC_NODE_PRODUCTION","sample","getRpcUrl","simpleRpcProvider","StaticJsonRpcProvider","getContract","ABI","value","isAddress","AddressZero","Error","ALCHEMY_URL","approve","tokenAddress","FeeContract","contract","parseUnits","Container","styled","Box","spacing","xxl","Membership","useState","tokenApproved","setTokenApproved","pendingStatus","setPendingStatus","checkAllowance","memberShipContract","useEffect","mintNFT","fetchSignature","Date","now","nonce","toString","approveToken","Button","variant","onClick"],"mappings":"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","file":"static/js/5.e5507028.chunk.js","sourcesContent":["import membershipAbi from \"config/abi/MembershipNFT.json\"\n\nexport enum ChainIdBsc {\n  MAINNET = 56,\n  TESTNET = 97,\n}\n\nexport enum ChainIdPolygon {\n  MAINNET = 137,\n  TESTNET = 80001,\n}\n\nconst polygonMainnetTokens = {\n  usdc: {\n    chainId: ChainIdPolygon.MAINNET,\n    address: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n    decimals: 18,\n    symbol: \"USDC\",\n    name: \"Polygon-Peg USD Coin\",\n    projectLink: \"https://www.centre.io/usdc\",\n  },\n}\n\nconst polygonTestnetTokens = {\n  link: {\n    chainId: ChainIdPolygon.TESTNET,\n    address: \"0x326c977e6efc84e512bb9c30f76e30c160ed06fb\",\n    decimals: 18,\n    symbol: \"LINK\",\n    name: \"Mumbai-Peg Chainlink Token\",\n    projectLink: \"https://chain.link/\",\n  },\n}\n\nexport const membershipContract = {\n  feeAddress:\n    process.env.NODE_ENV === \"development\"\n      ? polygonMainnetTokens.usdc.address\n      : polygonTestnetTokens.link.address,\n  allowance: process.env.NODE_ENV === \"development\" ? 50 : 1,\n  address:\n    process.env.NODE_ENV === \"development\"\n      ? \"0x8e68c81ba9e3264e236b6d2273f601b385baa7b3\"\n      : \"0x0e562f5D6869f20b5243E6C441149705906094E8\",\n  abi: membershipAbi,\n}\n\nexport const tokens =\n  process.env.NODE_ENV === \"development\"\n    ? polygonMainnetTokens\n    : polygonTestnetTokens\n\nexport const IPFS_GATEWAY = \"https://ipfs.io/ipfs\"\n","// libraries\nimport axios from \"axios\"\nimport { ethers } from \"ethers\"\nimport getProvider from \"wallets/utils\"\n\nconst getNonceSignature = async (providerName: string) => {\n  const chosenProvider = getProvider(providerName)\n  const provider =\n    providerName === \"metamask\"\n      ? new ethers.providers.Web3Provider(chosenProvider)\n      : new ethers.providers.Web3Provider(chosenProvider)\n  // console.log('Provider', provider);\n  const signer = provider.getSigner()\n  // console.log('Signer', signer);\n\n  const endpoint = `${process.env.REACT_APP_API_HOSTNAME}/api/membership/signature`\n\n  // console.log('Endpoint', endpoint);\n\n  const res = await axios.get(endpoint)\n\n  if (res && res.data) {\n    // console.log('Response:', res);\n    return res.data\n  }\n  return false\n}\n\nexport default getNonceSignature\n","import { createAlchemyWeb3 } from \"@alch/alchemy-web3\"\nimport getProvider from \"wallets/utils\"\nimport { ethers } from \"ethers\"\nimport { membershipContract } from \"config\"\n\nconst ALCHEMY_API_KEY = `${process.env.REACT_APP_ALCHEMY_HOSTNAME}${process.env.REACT_APP_ALCHEMY_API_KEY}`\nconst web3 = createAlchemyWeb3(ALCHEMY_API_KEY)\n\nconst mint = async (signature: string, message: string) => {\n  try {\n    const MembershipContract = new web3.eth.Contract(\n      // @ts-ignore\n      membershipContract.abi,\n      membershipContract.address\n    )\n\n    // console.log('MembershipContract', MembershipContract);\n    console.log(\"signature mint\", signature)\n    console.log(\"message mint\", message)\n\n    const providerName = \"metamask\"\n    const chosenProvider = getProvider(providerName)\n    const provider =\n      providerName === \"metamask\"\n        ? new ethers.providers.Web3Provider(chosenProvider)\n        : new ethers.providers.Web3Provider(chosenProvider)\n    // console.log('Provider', provider);\n    const signer = provider.getSigner()\n    const walletAddress = await signer.getAddress()\n    // console.log('walletAddress', walletAddress);\n\n    // set up transaction parameters\n    const transactionParameters = {\n      to: membershipContract.address,\n      from: walletAddress,\n      gas: ethers.utils.hexlify(450000),\n      data: MembershipContract.methods\n        .mint(walletAddress, signature, message)\n        .encodeABI(),\n    }\n\n    await chosenProvider\n      .request({\n        method: \"eth_sendTransaction\",\n        params: [transactionParameters],\n      })\n      .catch((error: any) => {\n        console.warn(\"error\", error)\n      })\n  } catch (error) {\n    console.warn(\"Membership mint error\", error)\n  }\n}\n\nexport default mint\n","import { Interface } from \"@ethersproject/abi\"\nimport ERC20_ABI from \"./erc20.json\"\nimport ERC20_BYTES32_ABI from \"./erc20_bytes32.json\"\n\nconst ERC20_INTERFACE = new Interface(ERC20_ABI)\n\nconst ERC20_BYTES32_INTERFACE = new Interface(ERC20_BYTES32_ABI)\n\nexport default ERC20_INTERFACE\nexport { ERC20_ABI, ERC20_BYTES32_INTERFACE, ERC20_BYTES32_ABI }\n","import sample from \"lodash/sample\"\n\nif (\n  process.env.NODE_ENV !== \"production\" &&\n  (!process.env.REACT_APP_PUBLIC_NODE_1 ||\n    !process.env.REACT_APP_PUBLIC_NODE_2 ||\n    !process.env.REACT_APP_PUBLIC_NODE_3)\n) {\n  throw Error(\"One base RPC URL is undefined\")\n}\n\n// Array of available nodes to connect to\nexport const nodes = [\n  process.env.REACT_APP_PUBLIC_NODE_1,\n  process.env.REACT_APP_PUBLIC_NODE_2,\n  process.env.REACT_APP_PUBLIC_NODE_3,\n]\n\nconst getNodeUrl = () => {\n  // Use custom node if available (both for development and production)\n  // However on the testnet it wouldn't work, so if on testnet - comment out the NEXT_PUBLIC_NODE_PRODUCTION from env file\n  if (process.env.REACT_APP_PUBLIC_NODE_PRODUCTION) {\n    return process.env.REACT_APP_PUBLIC_NODE_PRODUCTION\n  }\n  return sample(nodes)\n}\n\nexport default getNodeUrl\n","import { StaticJsonRpcProvider } from \"@ethersproject/providers\"\nimport getRpcUrl from \"utils/getRpcUrl\"\n\nconst RPC_URL = getRpcUrl()\n\nexport const simpleRpcProvider = new StaticJsonRpcProvider(RPC_URL)\n\nexport default null\n","import type { Signer } from \"@ethersproject/abstract-signer\"\nimport type { Provider } from \"@ethersproject/providers\"\nimport { getAddress } from \"@ethersproject/address\"\nimport { AddressZero } from \"@ethersproject/constants\"\nimport { JsonRpcSigner, Web3Provider } from \"@ethersproject/providers\"\nimport { Contract } from \"@ethersproject/contracts\"\nimport { simpleRpcProvider } from \"./providers\"\n\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value: any): string | false {\n  try {\n    return getAddress(value)\n  } catch {\n    return false\n  }\n}\n\n// account is not optional\nexport function getSigner(\n  library: Web3Provider,\n  account: string\n): JsonRpcSigner {\n  return library.getSigner(account).connectUnchecked()\n}\n\n// account is optional\nexport function getProviderOrSigner(\n  library: Web3Provider,\n  account?: string\n): Web3Provider | JsonRpcSigner {\n  return account ? getSigner(library, account) : library\n}\n\n// account is optional\nexport function getContract(\n  address: string,\n  ABI: any,\n  signer?: Signer | Provider\n): Contract {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n\n  return new Contract(address, ABI, signer ?? simpleRpcProvider)\n}\n","import { createAlchemyWeb3 } from \"@alch/alchemy-web3\"\nimport { ERC20_ABI } from \"config/abi/erc20\"\nimport { getContract } from \"utils\"\nimport { ethers } from \"ethers\"\nimport { membershipContract } from \"config\"\nimport getProvider from \"wallets/utils\"\n\nconst ALCHEMY_URL = `${process.env.REACT_APP_ALCHEMY_HOSTNAME}${process.env.REACT_APP_ALCHEMY_API_KEY}`\nconst web3 = createAlchemyWeb3(ALCHEMY_URL)\n\nconst approve = async () => {\n  try {\n    const tokenAddress = membershipContract.feeAddress\n    const FeeContract = new web3.eth.Contract(\n      // @ts-ignore\n      ERC20_ABI,\n      membershipContract.feeAddress\n    )\n    // console.log('Fee Token Address:', tokenAddress);\n    // const aa = getProviderOrSigner(library, account);\n    const chosenProvider = getProvider(\"metamask\")\n    const provider = new ethers.providers.Web3Provider(chosenProvider)\n    // console.log('Provider', provider);\n    const signer = provider.getSigner()\n    // console.log('Signer', signer);\n    const contract = getContract(tokenAddress, ERC20_ABI, signer)\n    // console.log('Contract', contract);\n    const walletAddress = await signer.getAddress()\n    console.log(\"Address:\", walletAddress)\n    const allowance = await contract.allowance(\n      walletAddress,\n      membershipContract.address\n    )\n    console.log(\"Allowance:\", allowance)\n    if (allowance < 50.0) {\n      // console.log('USDCContract', FeeContract);\n      // console.log('USDCContract methods', FeeContract.methods);\n      const transactionParameters = {\n        to: tokenAddress,\n        from: walletAddress,\n        data: FeeContract.methods\n          .approve(membershipContract.address, ethers.utils.parseUnits(\"1\", 18))\n          .encodeABI(),\n      }\n\n      // console.log('chosenProvider', chosenProvider);\n\n      await chosenProvider\n        .request({\n          method: \"eth_sendTransaction\",\n          params: [transactionParameters],\n        })\n        .catch((error: any) => {\n          console.warn(\"error\", error)\n        })\n    }\n\n    return true\n  } catch (error) {\n    // console.log('Membership approve error', error);\n    return false\n  }\n}\n\nexport default approve\n","import { Box, Button } from \"@mui/material\"\nimport styled from \"styled-components\"\nimport { ethers } from \"ethers\"\nimport spacing from \"theme/spacing\"\nimport getNonceSignature from \"api/membership\"\nimport mint from \"contracts/membership\"\nimport getProvider from \"wallets/utils\"\nimport approve from \"contracts/usdc\"\nimport { useState, useEffect } from \"react\"\nimport { getContract } from \"utils\"\nimport { membershipContract } from \"config\"\nimport { ERC20_ABI } from \"config/abi/erc20\"\n\nconst Container = styled(Box)`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin-right: ${spacing.xxl}px;\n  margin-left: ${spacing.xxl}px;\n  min-height: calc(100vh - 148px);\n`\n\nexport default function Membership(): JSX.Element {\n  const [tokenApproved, setTokenApproved] = useState(false)\n  const [pendingStatus, setPendingStatus] = useState(true)\n\n  const checkAllowance = async () => {\n    try {\n      const chosenProvider = getProvider(\"metamask\")\n      const provider = new ethers.providers.Web3Provider(chosenProvider)\n      const signer = provider.getSigner()\n      const memberShipContract = getContract(\n        membershipContract.feeAddress,\n        ERC20_ABI,\n        signer\n      )\n      console.log(\"Contract all\", memberShipContract)\n      const walletAddress = await signer.getAddress()\n      console.log(\"Address all:\", walletAddress)\n      console.log(\"membershipContract.address: all\", membershipContract.address)\n      const allowance = await memberShipContract.allowance(\n        walletAddress,\n        membershipContract.address\n      )\n      console.log(\"allowance:\", allowance)\n      console.log(\"membershipContract.allowance:\", membershipContract.allowance)\n      if (allowance >= membershipContract.allowance) {\n        setTokenApproved(true)\n      }\n    } catch (error) {\n      console.log(\"Error checking allowance\", error)\n    }\n  }\n\n  useEffect(() => {\n    checkAllowance()\n    setPendingStatus(false)\n  }, [])\n\n  const mintNFT = async (signature: string, message: string) => {\n    await mint(signature, message)\n    // console.log(res);\n  }\n\n  const fetchSignature = async () => {\n    const timestamp = Date.now()\n    const res = await getNonceSignature(\"metamask\")\n    if (res) {\n      const { signature, nonce } = res\n      await mintNFT(signature, nonce.toString())\n    }\n  }\n\n  const approveToken = async () => {\n    await approve()\n  }\n\n  return (\n    <Container>\n      {!pendingStatus &&\n        (!tokenApproved ? (\n          <Button variant=\"contained\" onClick={approveToken}>\n            APPROVE TOKEN\n          </Button>\n        ) : (\n          <Button variant=\"contained\" onClick={fetchSignature}>\n            MINT NFT\n          </Button>\n        ))}\n    </Container>\n  )\n}\n"],"sourceRoot":""}